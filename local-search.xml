<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>八股</title>
    <link href="/2025/02/27/%E5%85%AB%E8%82%A1/"/>
    <url>/2025/02/27/%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别?:"></a>进程和线程的区别?:</h3><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式?:"></a>进程间通信方式?:</h3><pre><code class="hljs">管道:    优点:简单,父子进程通信    缺点:只能单向 有限缓冲区FIFO:    优点:无亲缘关系进程通信    缺点:仅支持流量式数据消息队列:    优点:可存消息类型    缺点:受内核影响共享内存:    优点:速度快    缺点:需要同步机制信号量:    优点:控制进程同步    缺点:不能传输数据信号:    优点:进程间通知    缺点:只能传递信号套接字:    优点:适用于网络    缺点:复杂</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2025/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h6 id="1-1-2-计算机网络组成和功能"><a href="#1-1-2-计算机网络组成和功能" class="headerlink" title="1.1.2(计算机网络组成和功能):"></a>1.1.2(计算机网络组成和功能):</h6><pre><code class="hljs">从组成来看:硬件 软件 协议从工作方式来看:边缘部分 核心部分从逻辑功能来看:资源子网 通信子网计算机网络的功能:数据通信 资源共享 分布式处理 提高可靠性 负载均衡 其他</code></pre><h5 id="1-1-3-电路交换-报文交换-分组交换"><a href="#1-1-3-电路交换-报文交换-分组交换" class="headerlink" title="1.1.3(电路交换 报文交换 分组交换):"></a>1.1.3(电路交换 报文交换 分组交换):</h5><pre><code class="hljs">电路交换:    优点:通信前从主叫端到被叫端建立一条专用的物理通路,在通信的全部时间内,两个用户始终占用端到端的线路资源。数据直送,传输速率高    缺点:建立/释放连接,需要额外的时间开销。        线路被通信双方独占,利用率低。        线路分配的灵活性差。        交换节点不支持“差错控制”(无法发现传输过程中的发生的数据错误)报文交换:    优点:通信前无需建立连接        数据以“报文”为单位被交换节点间“存储转发”,通信线路可以灵活分配        在通信时间内,两个用户无需独占一整条物理线路。相比于电路交换,线路利用率高        交换节点支持“差错控制”(通过校验技术)    缺点:报文不定长,不方便存储转发管理        长报文的存储转发时间开销大、缓存开销大        长报文容易出错,重传代价高分组交换:    优点:通信前无需建立连接        数据以“分组”为单位被交换节点间“存储转发”,通信线路可以灵活分配        在通信时间内,两个用户无需独占一整条物理线路。相比于电路交换,线路利用率高        交换节点支持“差错控制”(通过校验技术)    缺点:相比于报文交换,控制信息占比增加        相比于电路交换,依然存在存储转发时延        报文被拆分为多个分组,传输过程中可能出现失序、丢等问题,增加处理的复杂度    相比于报文交换,分组交换改进了如下问题:        分组定长,方便存储转发管理        分组的存储转发时间开销小、缓存开销小        分组不易出错,重传代价低</code></pre><h5 id="1-1-5-计算机网络的性能指标"><a href="#1-1-5-计算机网络的性能指标" class="headerlink" title="1.1.5(计算机网络的性能指标):"></a>1.1.5(计算机网络的性能指标):</h5><pre><code class="hljs">分为速率 带宽 吞吐量 时延 时延带宽积 往返延迟 信道利用率信道:表示向某一方向传送信息的通道(信道≠通信线路)一条通信线路在逻辑上往往对应一条发送信道和一条接收信道速率(Speed):指连接到网络上的节点在信道上传输数据的速率。也称数据率或比特率、数据传输速率带宽(bandwidth):某信道所能传送的最高数据率结论:节点间通信实际能达到的最高速率，由带宽、节点性能共同限制。吞吐量(Throughput):指单位时间内通过某个网络(或信道、接口)的实际数据量。吞吐量受带宽限制、受复杂的网络负载情况影响(吞＋吐)时延(Delay):指数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间。有时也称为延迟或迟延。(总时延=发送时延+传播时延+处理时延+排队时延)发送时延又称传输时延(节点将数据推向信道所花的时间)(=数据长度/发送速率)  注意不要和传播时延搞混传播时延(电磁波在信道中传播一定的距离所花费的时间)(=信道长度/电磁波在管道传播速率)处理时间(被路由器处理所花的时间(如:分析首部、查找存储转发表))排队时延(数据排队进入、排队发出路由器所花的时间)时延带宽积的含义:一条链路中，已从发送端发出但尚未到达接收端的最大比特数(时延带宽积=传播时延x带宽)往返时延RTT(Round-Trip Time):表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。信道利用率:某个信道有百分之多少的时间是有数据通过的。(信道利用率=有数据通过的时间/(有数据通过的时间+没有数据通过的时间))信道利用率不能太低:浪费资源     信道利用率也不能太高:容易导致网络拥塞节假日高</code></pre><h5 id="1-2-1-计算机分层结构"><a href="#1-2-1-计算机分层结构" class="headerlink" title="1.2.1(计算机分层结构):"></a>1.2.1(计算机分层结构):</h5><pre><code class="hljs">网络的体系结构(Network Architecture)是计算机网络的各层及其协议的集合,就是这个计算机网络及其构件所应完成的功能的精确定义(不涉及实现)OSI参考模型(法律上的标准):应用层 表示层 会话层 运输层 网络层 数据链路层 物理层TCP/IP模型(实际上的标准):应用层 传输层 网际层 网络接口层五层模型(教学用的标准):应用层 传输层 网络层 数据链路层 物理层实体:在计算机网络的分层结构中,第n层中的活动元素(软件+硬件)通常称为第n层实体。不同机器上的同一层称为对等层,同一层的实体称为对等实体。协议:即网络协议(Network Protocol),是控制对等实体之间进行通信的规则的集合,是水平的。接口:即同一节点内相邻两层的实体交换信息的逻辑接口,又称为服务访问点(Service AccessPoint, SAP) .服务:服务是指下层为紧邻的上层提供的功能调用,它是垂直的。协议数据单元(PDU):对等层次之间传送的数据单位。第n层的PDU记为n-PDU服务数据单元(SDU):为元成上一层实体所要求的功能而传送的数据。第n层的SDU记为n-SDU。协议控制信息(PCL):控制协议操作的信息。第n层的PCI记为n-PCI。PDU=SDU+PCL协议:即网络协议(Network Protocol),是控制对等实体之间进行通信的规则的集合,是水平的。协议由语法、语义和同步三部分组成(协议的三要素):语法,数据与控制信息的格式。例如,协议控制信息(首部)部分占几个字节、每个字节是什么含义;协议的数据部分最多由多少字节。语义,即需要发出何种控制信息、完成何种动作及做出何种应答。例如,协议中需要明确规定:发送方完数据后,接收方是否需要“应答”,以及应答的种类有哪些(如:传输成功、传输失败)同步(或时序),执行备种操作的条件、时序关系等,即事件实现顺序的详细说明。例如,发送方发完数据后,接收方需要立即应答。如果发送方在10秒内未收到“传输成功”应答,则发送方会再次发送数据。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>四大件</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL</title>
    <link href="/2025/02/10/STL/"/>
    <url>/2025/02/10/STL/</url>
    
    <content type="html"><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器:"></a>迭代器:</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">容器类型&lt;数据类型,数据类型&gt;::iterator it=a.begin()  //迭代器一般用于指向位置</code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><pre><code class="hljs">迭代器it可以当作是指针 即it是地址 *it是值所有不支持随机访问迭代器的容器,不可以用标准算法 比如:list容器不能用sort(list)排序只能用l.sort()不支持随机访问迭代器的容器,内部会提供对应的一些算法</code></pre><h3 id="1-vector-数组"><a href="#1-vector-数组" class="headerlink" title="1.vector(数组):"></a>1.vector(数组):</h3><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">vector&lt;数据类型&gt;v1</code></pre><h5 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">v1.begin()//指向第一个v1.end()//指向最后一个v1.push_back(a)//把a加入到容器里v1.pop_back()//删除最后一个数 没有参数v1.front()//直接获取第一个元素 和begin不一样 不是指向是直接获取v1.back()//直接获取最后一个元素 和end不一样 不是指向是直接获取v1.insert(a,b,c)//第一个参数是迭代器即在哪个位置插入数字,第二个参数是插入数字的个数默认1个,第三个参数是要插入的数字.       v1.insert(v1.begin(),2,100)在开头插入两个100v1.insert(v1.begin(),100)在开头插入1个100v1.erase(a,b)//删除 参数是迭代器即删除的位置v1.erase(v1.begin())//删除第一个位置:如果有两个参数则是删除一个区间.一个参数就只是删除一个数字v1.clear()//清空全部v1.empty()//判断是否为空 为空返回1v1.capacity()和v1.size()//区别:capacity永远大于等于size.capacity反映的是容器的全部大小,size反映的是现存的数值长度的大小v1.resize(a,b)//若a大于原来的长度则用b数填充剩下的空余位置若未写b则默认0填充,若a小于原来的长度(这种情况就没有b)则删除超出的长度.重置的是大小不是容量,容量不变v1.swap(v2)//交换v1和v2的指向(整体交换包括大小和容量)    实际用途收缩内存:vector&lt;int&gt;(v).swap(v)//先建立一个匿名(用完就释放)然后和v交换后然后释放掉内存v1.reserve(a)/容器预留a个元素长度,预留位置不初始化,元素不可访问</code></pre><h5 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造:"></a>拷贝构造:</h5><pre><code class="hljs">vector&lt;int&gt;v4(v3)//把v3的值拷贝到v4里,两者里面的值完全一样</code></pre><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值:"></a>赋值:</h5><pre><code class="hljs">vector&lt;int&gt;v2 v2=v1//等号直接赋值</code></pre><h5 id="访问-遍历"><a href="#访问-遍历" class="headerlink" title="访问&#x2F;遍历:"></a>访问&#x2F;遍历:</h5><pre><code class="hljs">使用for循环遍历里面的元素时候可以带上迭代器:for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) cout&lt;&lt;*it    迭代器看作是一个指针或者位置或者用[]的方式(就和数组一样,和下面的方法一样不用迭代器):for(i=0;i&lt;v1.size();i++)cout&lt;&lt;v1[i]或者v1.at(i)的方式for(i=0;i&lt;v1.size();i++)cout&lt;&lt;v1.at(i)</code></pre><h3 id="2-deque-双端队列"><a href="#2-deque-双端队列" class="headerlink" title="2.deque(双端队列):"></a>2.deque(双端队列):</h3><p>允许在两端插入和删除</p><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">deque&lt;int&gt;d</code></pre><h5 id="用法-1"><a href="#用法-1" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">d.push_back(i)//尾插d.push_front(i)//头插d.pop_back()//尾删d.pop_front()//头删d.begin()//指向起始位置d.end()//指向结束位置d1.empty()//判断是否为空 为空返回1d1.size()//deque没有capacityd1.resize(a,b)//若a大于原来的长度则用b数填充剩下的空余位置若未写b则默认0填充,若a小于原来的长度(这种情况就没有b)则删除超出的长度.重置的是大小不是容量,容量不变d1.insert(a,b,c)//第一个参数是迭代器即在哪个位置插入数字,第二个参数是插入数字的个数默认1个,第三个参数是要插入的数字.       d1.insert(d1.begin(),2,100)在开头插入两个100d1.insert(d1.begin(),100)在开头插入1个100也可以插入区间d1.insert(d1.begin(),d2.begin(),d2.end())//在d1的开头插入区间d2d1.erase(a,b)//删除 参数是迭代器即删除的位置v1.erase(v1.begin())//删除第一个位置:如果有两个参数则是删除一个区间.一个参数就只是删除一个数字d1.clear()//清空全部d1.front()//直接获取第一个元素 和begin不一样 不是指向是直接获取d1.back()//直接获取最后一个元素 和end不一样 不是指向是直接获取</code></pre><h5 id="拷贝构造-1"><a href="#拷贝构造-1" class="headerlink" title="拷贝构造:"></a>拷贝构造:</h5><pre><code class="hljs">deque&lt;int&gt;d4(d3)//把d3的值拷贝到d4里,两者里面的值完全一样</code></pre><h5 id="访问"><a href="#访问" class="headerlink" title="访问:"></a>访问:</h5><pre><code class="hljs">和vector的迭代器使用方法一样for(deque&lt;int&gt;::iterator it=d.begin();it!=d.end();it++) cout&lt;&lt;*it或者用[]的方式(就和数组一样,和下面的方法一样不用迭代器):for(i=0;i&lt;d1.size();i++)cout&lt;&lt;d1[i]或者d1.at(i)的方式for(i=0;i&lt;d1.size();i++)cout&lt;&lt;d1.at(i)</code></pre><h3 id="3-stack-栈"><a href="#3-stack-栈" class="headerlink" title="3.stack(栈):"></a>3.stack(栈):</h3><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">stack&lt;int&gt;s</code></pre><h5 id="用法-2"><a href="#用法-2" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">s.push(i)//入栈s.top()//查看栈顶元素s.size()//查看大小s.pop()//出栈s.empty()//是否为空 空返回1</code></pre><h3 id="4-queue-队列"><a href="#4-queue-队列" class="headerlink" title="4.queue(队列):"></a>4.queue(队列):</h3><p>只能在队尾添加 队头弹出</p><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">queue&lt;int&gt;q</code></pre><h5 id="用法-3"><a href="#用法-3" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">q.push(i)//入队q.size()//查看大小q.back()//返回最后一个元素q.front()//返回第一个元素q.pop()//出队q.empty()//是否为空 空返回1</code></pre><h3 id="5-list-链表"><a href="#5-list-链表" class="headerlink" title="5.list(链表):"></a>5.list(链表):</h3><pre><code class="hljs">list链表不能像别的类型一样用[]的形式访问里面的元素,没有这种方式,也不能用at的方式,不支持随机访问,使用迭代器只能++(即挨个遍历)访问不能跳着访问</code></pre><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">list&lt;int&gt;l</code></pre><h5 id="用法-4"><a href="#用法-4" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">l.push_back(a)//尾部添加元素l.push_front(a)//头部添加元素l.pop_back()//尾部删除l.pop_front()//头部删除l.begin()//起始位置l.end()//结束位置l.front()//返回第一个元素l.back()//返回最后一个元素l1.swap(l2)//l1和l2交换l.size()//获取大小l.empty()//判断是否为空 是返回1l.resize(a,b)//重新指定大小(不是容量) 默认0填充(b为填充参数) 超出大小则删除多余l.clear()//清除所有l.erase(a)//删除 参数a是位置l.remove(a)//删除容器里所有和a值匹配的元素l.insert(a,b)//插入元素 参数a是位置 参数b是插入的数字l.reverse()//反转序列l.sort()//排序 默认升序</code></pre><h5 id="拷贝构造-2"><a href="#拷贝构造-2" class="headerlink" title="拷贝构造:"></a>拷贝构造:</h5><pre><code class="hljs">list&lt;int&gt;l3(l2)//l2拷贝给l3</code></pre><h3 id="6-set-multiset-树-插入自动排序-升序"><a href="#6-set-multiset-树-插入自动排序-升序" class="headerlink" title="6.set&#x2F;multiset(树,插入自动排序,升序):"></a>6.set&#x2F;multiset(树,插入自动排序,升序):</h3><h5 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h5><pre><code class="hljs">set不允许有重复的元素multiset允许有重复的元素</code></pre><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">set&lt;int&gt; s</code></pre><h5 id="用法-5"><a href="#用法-5" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">s.insert()//插入数据s.empty()//判断是否为空 是返回1s2.swap(s1)//s1和s2互换s.clear()//清空S.erase(a)//a可以是位置参数也可以是容器里的值作为参数 注意删除的是排序后的s.find(a)//查照元素在容器里的位置 参数a是容器里的元素s.count()//统计元素出现的个数 set里只会出现1或0 在multiset里会出现大于等于0的所有可能</code></pre><h5 id="拷贝构造-3"><a href="#拷贝构造-3" class="headerlink" title="拷贝构造:"></a>拷贝构造:</h5><pre><code class="hljs">set&lt;int&gt;s2(s1)//s1拷贝给s2</code></pre><h3 id="7-pair-对组"><a href="#7-pair-对组" class="headerlink" title="7.pair(对组):"></a>7.pair(对组):</h3><h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">第一种:pair&lt;数据类型,数据类型&gt; p(值,值)  比如pair&lt;string,int&gt; p(&quot;Tom&quot;,20)第二种:pair&lt;数据类型,数据类型&gt; p=make_pair(值,值)   比如pair&lt;string,int&gt; p=make_pair(&quot;jerry&quot;,30)访问形式:p.first(输出对组中的第一个值) p.second(输出对组中的第二个值)</code></pre><h3 id="8-map-multimap-哈希表-自动排序-升序"><a href="#8-map-multimap-哈希表-自动排序-升序" class="headerlink" title="8.map&#x2F;multimap(哈希表,自动排序,升序):"></a>8.map&#x2F;multimap(哈希表,自动排序,升序):</h3><pre><code class="hljs">map中的所有元素都是pair类型pair中的第一个元素为key(键值),起到索引作用,第二个元素为value(实值)所有元素都会根据元素的键值自动升序排序</code></pre><h5 id="本质"><a href="#本质" class="headerlink" title="本质:"></a>本质:</h5><pre><code class="hljs">map/multimap属于关联式容器,底层结构是用二叉树实现</code></pre><h5 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h5><pre><code class="hljs">可以根据key值快速查找到value值</code></pre><h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别:"></a>区别:</h5><pre><code class="hljs">map:不允许容器中有重复key值元素multimap:允许容器中有重复key值元素</code></pre><h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义:"></a>定义:</h5><pre><code class="hljs">map&lt;int,int&gt;m</code></pre><h5 id="用法-6"><a href="#用法-6" class="headerlink" title="用法:"></a>用法:</h5><pre><code class="hljs">m.insert(pair&lt;数据类型,数据类型&gt;(键值,实值))//第一种插入方法m.insert(make_pair(键值,实值))//第二种插入方法m.insert(map&lt;数据类型,数据类型&gt;::value_type(键值,实值))//第三种插入方法m[键值]=实值//第四种插入方法m.begin()//起始位置m.end()//结束位置m.size()//返回容器里元素的数目m.empty()//判断是否为空 是返回1m.swap(m2)//m和m2交换(键值和实值都交换)m.clear()//清空元素m.erase(pos)//删除pos迭代器所指的元素,返回下一个元素的迭代器m.erase(beg,end)//删除区间[beg,end]的所有元素,返回下一个元素的迭代器m.erase(key)//删除容器中之为key的元素(键值和实值全删除)m.find(key)//查找键值为key的元素 如果找到元素find返回一个指向该元素的迭代器,如果未找到则返回end()迭代器:end()迭代器是一个超出map末尾的迭代器,不能被解引用m.count(key)//统计键值为key的出现的个数,在map当中只会出现0或1,在multimap中会出现大于等于0次,返回整形</code></pre><h5 id="拷贝构造-4"><a href="#拷贝构造-4" class="headerlink" title="拷贝构造:"></a>拷贝构造:</h5><pre><code class="hljs">map&lt;数据类型,数据类型&gt;m2(m1)//把m1拷贝给m2</code></pre><h5 id="关于输出"><a href="#关于输出" class="headerlink" title="关于输出:"></a>关于输出:</h5><pre><code class="hljs">输出键值时可以:cout&lt;&lt;(*m).first或cout&lt;&lt;m-&gt;first输出实值时可以:cout&lt;&lt;(*m).second或cout&lt;&lt;m-&gt;second</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2025/02/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/02/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章:"></a>第一章:</h3><h5 id="1-1-操作系统功能"><a href="#1-1-操作系统功能" class="headerlink" title="1.1(操作系统功能):"></a>1.1(操作系统功能):</h5><pre><code class="hljs">操作系统的四个特征:并发 共享 虚拟 异步(并发和共享是最基本的必须要有)并发:是指两个或多个事件在同一时间间隔内发生,这些事件宏观上是同时发生的,但在微观上是交替发生的(混淆概念并行:指两个或多个事件在同一时刻同时发生)共享:分为互斥共享和同时共享.所谓的同时共享往往是在宏观上的,而在微观上这些进程可能是交替着进行的(也有可能是同时)虚拟:分为空分复用技术(如虚拟存储技术)和时分复用技术(如虚拟处理器技术)异步:异步是指在多到程序环境下允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停,以不可预知的速度向前推进.</code></pre><h5 id="1-3-1-cpu状态"><a href="#1-3-1-cpu状态" class="headerlink" title="1.3.1(cpu状态):"></a>1.3.1(cpu状态):</h5><pre><code class="hljs">cpu有两种状态:内核态(核心态,管态)和用户态(目态)         (如何区分:cpu里面有一个寄存器叫程序状态字寄存器(PSW),其中有一个二进制位,1表示内核态,0表示用户态)         处于内核态说明正在运行的是内核程序,此时可以执行特权指令         处于用户态说明正在运行的是应用程序,此时只能执行非特权指令两种状态的切换:内核-&gt;用户:执行一条特权指令---修改PSW的标志位为用户态          用户-&gt;内核:由中断引发,硬件自动完成变态过程</code></pre><h5 id="1-3-2-中断"><a href="#1-3-2-中断" class="headerlink" title="1.3.2(中断):"></a>1.3.2(中断):</h5><pre><code class="hljs">中断类型:        外中断:与当前执行的指令无关,中断信号来源于cpu外部 如:时钟中断,I/O请求中断        内中断(也称为异常,例外):与当前执行的指令有关,中断信号来源于cpu内部 如:陷阱,陷入 故障 终止不同的中断信号,需要用不同的中断处理程序来处理.当cpu检测到中断信号后,会根据中断信号的类型去查找&quot;中断向量表&quot;,以此来找到相应地中断处理程序在内存中的存放位置</code></pre><h5 id="1-4-源语"><a href="#1-4-源语" class="headerlink" title="1.4(源语):"></a>1.4(源语):</h5><pre><code class="hljs">源语是一种特殊的程序,具有原子性,也就是说,这段程序的运行必须一气呵成,不可被中断</code></pre><h5 id="1-6-虚拟机"><a href="#1-6-虚拟机" class="headerlink" title="1.6(虚拟机):"></a>1.6(虚拟机):</h5><pre><code class="hljs">虚拟机:使用虚拟化技术,将一台物理机器虚拟化成多台虚拟机器,每个虚拟机器都可以独立运行一个操作系统第一类VMM,直接运行在硬件上  第二类VMM,运行在宿主操作系统上</code></pre><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章:"></a>第二章:</h3><h5 id="2-1-1-2-1-2-进程的概念-组成-特征"><a href="#2-1-1-2-1-2-进程的概念-组成-特征" class="headerlink" title="2.1.1+2.1.2(进程的概念 组成 特征):"></a>2.1.1+2.1.2(进程的概念 组成 特征):</h5><pre><code class="hljs">进程实体(进程映像)组成(如果不严谨也可以是进程的组成):由PCB,程序段,数据段组成(进程是动态的,进程实体(进程映像)是静态的)PCB是给操作系统用的,程序段 数据段是给进程自己用的,与进程自身的运行逻辑有关PCB是进程存在的唯一标志进程实体和进程的区别:进程实体反应了进程在某一时刻的状态(可以理解为进程实体是进程在某一时刻的快照)进程定义:进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位,进程的特征:动态性 并发性 独立性 异步性 结构性注意:进程是能独立运行,独立获得资源,独立接受调度的基本单位(注意和后面的线程进行区分)</code></pre><h5 id="2-1-3-进程的状态与转换"><a href="#2-1-3-进程的状态与转换" class="headerlink" title="2.1.3(进程的状态与转换):"></a>2.1.3(进程的状态与转换):</h5><pre><code class="hljs">状态流程:创建态-&gt;就绪态-&gt;运行态-&gt;(主动行为)阻塞态-&gt;(被动行为)就绪态-&gt;......-&gt;(结束)终止态(三种基本状态:运行态 就绪态 阻塞态)进程PCB中,会有一个变量state来表示进程的当前状态注意:不能由阻塞态直接转化为运行态,也不能由就绪态直接转化为阻塞态(因为进入阻塞态是进程主动请求的,必须要进程在运行时才能发出这种请求)进程的组织方式:链接方式 索引方式</code></pre><h5 id="2-1-4-进程控制"><a href="#2-1-4-进程控制" class="headerlink" title="2.1.4(进程控制):"></a>2.1.4(进程控制):</h5><pre><code class="hljs">原语的执行具有原子性,即执行过程只能一气呵成,期间不允许被中断.可以用关中断指令和开中断指令这两个特权指令实现原子性CPU执行了关中断指令后,就不再例行检查中断信号(本来执行完一条指令就要检查一次)直到执行开中断指令后才会恢复检查</code></pre><h5 id="2-1-6-线程"><a href="#2-1-6-线程" class="headerlink" title="2.1.6(线程):"></a>2.1.6(线程):</h5><pre><code class="hljs">可以把线程理解为轻量级进程线程定义:线程是一个基本的cpu执行单元,也是程序执行流的最小单位线程几乎不拥有系统资源,它只是调度的基本单位,进程是拥有系统资源引入线程后的变化:    引入线程之后,不仅是进程之间可以并发,进程内的各线程之间也可以并发,从而进一步提升了系统的并发度,使得一个进程内也可以并发处理各种任务    进程和线程的区别:引入线程后,进程只作为除cpu之外的系统资源的分配单元(进程不再是系统调度的基本单位,线程是调度的基本单位,进程现在只是资源分配的基本代单位)    系统开销:传统的进程间并发需要切换进程的运行环境,系统开销很大.   进程间并发如果是同一进程内的线程切换则不需要切换进程,系统开销很小.   引入线程后并发所带来的系统开销减小线程的属性:    1.线程是处理机调度单位    2.多cpu计算机中各个线程可占用不同的cpu    3.每个线程都有一个线程ID,线程控制块(TCB)(类似于PCB)    4.线程也有就绪 阻塞 运行三种基本状态    5.线程几乎不拥有系统资源    6.同一进程的不同线程间共享进程资源    7.由于共享内存地址空间,同一进程中的线程间通信甚至无需系统干预    8.同一进程中的线程切换,不会引起进程切换    9.不同进程中的线程切换,会引起进程切换    10.切换同进程内的线程,系统开销很小    11.切换进程,系统开销很大线程的实现方式:    用户级线程:        用户级线程由应用程序通过线程库实现,所有的线程管理工作都由应用程序负责(包括线程切换)        用户级线程中线程切换可以在用户态下即可完成 无需操作系统参与        在用户看来是有多个线程但是在操作系统内核看来并意识不到线程的存在          用户级线程就是从用户视角能看到的线程        优点:            用户级线程的切换在用户空间即可完成 不需要切换到核心态 线程管理的系统开销小 效率高        缺点:            当一个用户级线程被阻塞后 整个进程都会被阻塞 并发度并不高 多个线程不可在多核处理机上并行运行            内核级线程(由操作系统支持的线程):        内核级线程的管理工作由操作系统内核完成。        线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。        操作系统会为每个内核级线程建立相应的TCB  通过TCB对线程进行管理。        内核级线程就是从操作系统内核视角看能看到的线程        优点:            当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。        缺点:            一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。    多线程模型(在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型):        一对一模型:            一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。            优点:                当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。            缺点:                一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。        多对一模型:            多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。            优点:                用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高            缺点:                当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行                        重点:操作系统只能看见内核级线程,因此只有内核级线程才是处理机分配的单位        多对多模型:            n用户及线程映射到m个内核级线程（n&gt;=m）每个用户进程对应 m 个内核级线程 克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)又克服了一对一模型中一个用户进程占用太多内核级线程,开销太大的缺点。            可以这么理解:                用户级线程是代码逻辑的载体   内核级线程是运行机会的载体                一段逻辑代码只有获得了运行机会才能被CPU执行(内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞)</code></pre><h5 id="2-2-1-调度的概念-层次"><a href="#2-2-1-调度的概念-层次" class="headerlink" title="2.2.1(调度的概念 层次):"></a>2.2.1(调度的概念 层次):</h5><pre><code class="hljs">三层调度:    高级调度(作业调度):按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程                      外存→内存(面向作业)                      发生频率最低                      无-&gt;创建态-&gt;就绪态    中级调度(内存调度):                      按照某种规则，从挂起队列中选择合适的进程将其数据调回内存                      外存→内存(面向进程)                      发生频率中等                      挂起态-&gt;就绪态(阻塞态挂起-&gt;阻塞态)    低级调度(进程调度):                      按照某种规则，从就绪队列中选择一个进程为其分配处理机                      内存-&gt;CPU                      发生频率最高                      就绪态-&gt;运行态</code></pre><h5 id="2-2-2-进程调度的时机-切换-过程-方式"><a href="#2-2-2-进程调度的时机-切换-过程-方式" class="headerlink" title="2.2.2(进程调度的时机 切换 过程 方式):"></a>2.2.2(进程调度的时机 切换 过程 方式):</h5><pre><code class="hljs">进程调度的方式:    非剥夺调度方式(非抢占式):只允许进程主动放弃处理机 在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态。 开销小 无法及时处理紧急任务    剥夺调度方式(抢占式):当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程。可以优先处理紧急进程注意:进程切换是有代价的,因此如果过于频繁的进行进程调度、切换,必然会使整个系统的效率降低,使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少。闲逛进程:调度程序永远的备胎 没有其他就绪进程时候 运行闲逛进程(也就是说CPU永远不会停下来 因为有相关进程)闲逛进程特性:优先级最低 能耗低 可以是0地址指令,占一个完整的指令周期(指令周期末尾例行检查中断)</code></pre><h5 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2.3(调度算法的评价指标):"></a>2.2.3(调度算法的评价指标):</h5><pre><code class="hljs">cpu利用率:指CPU忙碌的时间占总时间的比例(利用率=忙碌的时间/总时间)系统吞吐量:单位时间内完成作业的数量(系统吞吐量=总共完成了多少道作业/总共花费多少时间)周转时间:是指从作业被提交给系统开始到作业完成为止的这段时间间隔(周转时间=作业完成时间-作业提交时间)(平均周转时间=各作业周转时间之和/作业数)(它包括四个部分:作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中,可能发生多次。)带权周转时间=作业周转时间/作业实际运行时间=(作业完成时间-作业提交时间)/作业实际运行时间(带权周转时间必然&gt;=1 带权周转时间与周转时间都是越小越好)平均带权周转时间=各作业带权周转时间之和/作业数等待时间:指进程/作业处于等待处理机状态时间之和,等待时间越长,用户满意度越低。(对于进程来说,等待时间就是指进程建立后等待被服务的时间之和,在等待I/O完成的期间其实进程也是在被服务的,所以不计入等待时间。)(对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间。)相应时间:指从用户提交申请到首次产生响应时间所用的时间</code></pre><h5 id="2-2-5-调度算法"><a href="#2-2-5-调度算法" class="headerlink" title="2.2.5(调度算法):"></a>2.2.5(调度算法):</h5><pre><code class="hljs">饥饿:某进程/作业长期得不到服务-----------------------------------适合批处理操作系统------------------------------先来先服务(FCFS):按照到达的先后顺序调度,先到的先调度,先到先得,类似队列先进先出    算法思想:主要从公平的角度考虑(类似于生活中的排队买东西)    算法规则:按照作业/进程到达的先后顺序进行服务    用于作业/进程调度:用于作业调度时,考虑的是哪个作业先到达后备队列 用于进程调度时,考虑的是哪个进程先到达就绪队列    是否可抢占:非抢占式的算法    优点:公平 算法实现简单    缺点:排在长作业(进程)后面的短作业需要等待很长时间,带权周转时间很大,对短作业来说用户体验不好 即FCFS算法对长作业有利,对短作业不利    是否会导致饥饿:否短作业优先(SJF):非抢占式:每次调度时选择当前已到达且运行时间最短的作业/进程。抢占式:每当有进程加入就绪队列改变时就需要调度,如果新到达的进程剩余时间比当前运行的进程剩余时间更短,则由新进程抢占处理机,当前运行进程重新回到就绪队列。另外,当一个进程完成时也需要调度    算法思想:追求最少的平均等待时间,最少的平均周转时间、最少的平均平均带权周转时间    算法规则:最短的作业/进程优先得到服务(所谓“最短”,是指要求服务时间最短)    用于作业/进程调度:即可用于作业调度,也可用于进程调度。用于进程调度时称为“短进程优先(SPF)算法”    是否可抢占:SJF和SPF是非抢占式的算法。但是也有抢占式的版本 最短剩余时间优先算法(SRTN)    优点:“最短的”平均等待时间、平均周转时间    缺点:不公平。对短作业有利,对长作业不利。可能产生饥饿现象。另外,作业/进程的运行时间是由用户提供的,并不一定真实,不一定能做到真正的短作业优先    是否会导致饥饿:会,如果短进程/作业源源不断的到来,长作业会饥饿甚至饿死高响应闭优先(HRRN):非抢占式的调度算法,只有当前运行的进程主动放弃CPU时(正常/异常完成,或主动阻塞),才需要进行调度,调度时计算所有就绪进程的响应比,选响应比最高的进程上处理机。    算法思想:要综合考虑作业/进程的等待时间和要求服务的时间    算法规则:在每次调度时先计算各个作业/进程的响应比,选择响应比最高的作业/进程为其服务(相应比=(等待时间+要求服务时间)/要求服务时间)    用于作业/进程调度:即可用于作业调度,也可用于进程调度    是否可抢占:非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时,才需要调度,才需要计算响应比    优缺点:综合考虑了等待时间和运行时间(要求服务时间) 等待时间相同时,要求服务时间短的优先(SJF的优点) 要求服务时间相同时,等待时间长的优先(FCFS的优点) 对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而避免了长作业饥饿的问题    是否会导致饥饿:不会-------------------------------------适合交互式操作系统(包括分布式操作系统 实时操作系统)---------------------------------------------时间片轮转(RR):时间片轮转调度算法:轮流让就绪队列中的进程依次执行一个时间片(每次选择的都是排在就绪队列队头的进程)    算法思想:公平地、轮流地为各个进程服务,让每个进程在一定时间间隔内都可以得到响应    算法规则:按照各进程到达就绪队列的顺序,轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队。    用于作业/进程调度:用于进程调度(只有作业放入内存建立了相应的进程后,才能被分配处理机时间片) 只能用于进程    是否可抢占:若进程未能在时间片内运行完,将被强行剥夺处理机使用权,因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到    优点:公平;响应快,适用于分时操作系统;    缺点:由于高频率的进程切换,因此有一定开销;不区分任务的紧急程度。    是否会导致饥饿:不会    注意点(补充):如果时间片太大,使得每个进程都可以在一个时间片内就完成,则时间片轮转调度算法退化为先来先服务调度算法,并且会增大进程响应时间。因此时间片不能太大。另一方面,进程调度、切换是有时间代价的(保存、恢复运行环境),因此如果时间片太小,会导致进程切换过于频繁,系统会花大量的时间来处理进程切换,从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。优先级调度算法:非抢占式的优先级调度算法:每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。抢占式的优先级调度算法:每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外,当就绪队列发生改变时也需要检查是会发生抢占。    算法思想:随着计算机的发展,特别是实时操作系统的出现,越来越多的应用场景需要根据任务的紧急程度来决定处理顺序    算法规则:调度时选择优先级最高的作业/进程    用于作业/进程调度:既可用于作业调度,也可用于进程调度。甚至,还用于I/o调度中    是否可抢占:抢占式、非抢占式都有。做题时的区别在于:非抢占式只需在进程主动放弃处理机时进行调度即可,而抢占式还需在就绪队列变化时,检查是否会发生抢占。    优点:用优先级区分紧急程度、重要程度,适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。    缺点:若源源不断地有高优先级进程到来,则可能导致饥饿    是否会导致饥饿:会    补充:就绪队列未必只有一个,可以按照不同优先级来组织。另外,也可以把优先级高的进程排在更靠近队头的位置        根据优先级是否可以动态改变,可将优先级分为静态优先级和动态优先级两种。        静态优先级:创建进程时确定,之后一直不变。        动态优先级:创建进程时有一个初始值,之后会根据情况动态地调整优先级。    通常:        系统进程优先级高于用户进程        前台进程优先级高于后台进程        操作系统更偏好I/O型进程(或称I/O繁忙型进程)        注:与I/O型进程相对的是计算型进程(或称CPU繁忙型进程)    可以从追求公平、提升资源利用率等角度考虑:        如果某进程在就绪队列中等待了很长时间,则可以适当提升其优先级        如果某进程占用处理机运行了很长时间,则可适当降低其优先级        如果发现一个进程频繁地进行I/O操作,则可适当提升其优先级多级反馈队列调度算法:设置多级就绪队列,各级队列优先级从高到低,时间片从小到大新进程到达时先进入第1级队列,按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束,则进程进入下一级队列队尾。如果此时已经在最下级的队列,则重新放回最下级队列队尾只有第k级队列为空时,才会为k+1级队头的进程分配时间片    算法思想:对其他调度算法的折中权衡    算法规则:1. 设置多级就绪队列,各级队列优先级从高到低,时间片从小到大            2. 新进程到达时先进入第1级队列,按FCFS原则排队等待被分配时间片,若用完时间片进程还未结束,则进程进入下一级队列队尾。如果此时已经是在最下级的队列,则重新放回该队列队尾            3. 只有第k级队列为空时,才会为k+1级队头的进程分配时间片    用于作业/进程调度:用于进程调度    是否可抢占:抢占式的算法。在k级队列的进程运行过程中,若更上级的队列(1~k-1级)中进入了一个新进程,则由于新进程处于优先级更高的队列中,因此新进程会抢占处理机,原来运行的进程放回k级队列队尾。    优缺点:对各类型进程相对公平(FCFS的优点);每个新到达的进程都可以很快就得到响应(RR的优点);短进程只用较少的时间就可完成(SPF的优点);不必实现估计进程的运行时间(避免用户作假);可灵活地调整对各类进程的偏好程度,比如CPU密集型进程、1/O密集型进程(拓展:可以将因I/O而阻塞的进程重新放回原队列,这样I/O型进程就可以保持较高优先级)    是否会导致饥饿:会    调度算法总结:    比起早期的批处理操作系统来说,由于计算机造价大幅降低,因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。(比如UNIX使用的就是多级反馈队列调度算法)其他算法(多级队列调度算法):系统中按进程类型设置多个队列,进程创建成功后插入某个队列    队列之间可采取固定优先级,或时间片划分固定优先级:高优先级空时低优先级进程才能被调度时间片划分:如三个队列分配时间50%、40%、10%    各队列可采用不同的调度策略,如:-系统进程队列采用优先级调度 交互式队列采用RR 批处理队列采用FCFS</code></pre><h5 id="2-3-1-同步和互斥概念"><a href="#2-3-1-同步和互斥概念" class="headerlink" title="2.3.1(同步和互斥概念):"></a>2.3.1(同步和互斥概念):</h5><pre><code class="hljs">同步:同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。互斥:我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后。另一个进程才能去访问临界资源。对临界资源的互斥访问，可以分成四个部分:进入区(上锁) 临界区(访问) 退出区(解锁) 剩余区(其他处理)    注意:临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”。遵循的原则:    1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;    2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待:    3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿);    4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</code></pre><h5 id="2-3-2-互斥的实现方法-软件-硬件"><a href="#2-3-2-互斥的实现方法-软件-硬件" class="headerlink" title="2.3.2(互斥的实现方法:软件 硬件)"></a>2.3.2(互斥的实现方法:软件 硬件)</h5><pre><code class="hljs">软件:    单标志法:        两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋子</code></pre><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">p0进程:<br><span class="hljs-type">int</span> ture=<span class="hljs-number">0</span> <span class="hljs-comment">//turn 表示当前允许进入临界区的进程号 当前只能进入0进程</span><br><span class="hljs-keyword">while</span>(ture!=<span class="hljs-number">0</span>);<span class="hljs-comment">//若ture不等于0则一直进入循环等待直到ture等于0 注意此循环后有分号即这一条循环语句只包括自身</span><br>critical section;<span class="hljs-comment">//访问临界资源</span><br>turn=<span class="hljs-number">1</span>;<span class="hljs-comment">//解锁 并把权限赋给1号进程</span><br>remainder section:<span class="hljs-comment">//剩余其他操作</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">    此算法无法满足空闲让尽原则(因为如果进程0进入临界资源但是一直不访问和不允许其他进程访问就会占用资源)</code></pre><p><img src="/os/%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95.png" alt="图示"></p><pre><code class="hljs">    双标志先检查法:        算法思想:设置一个布尔型数组flag[],数组中各个元素用来标记各进程想进入临界区的意愿,比如“flag[0]=ture”意味着0号进程PO现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志flag[i]设为true,之后开始访问临界区。</code></pre><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sqf">Bool <span class="hljs-built_in">flag</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">//表示进入临界区意愿的数组</span><br><span class="hljs-built_in">flag</span>[<span class="hljs-number">0</span>]=<span class="hljs-literal">false</span>;<br><span class="hljs-built_in">flag</span>[<span class="hljs-number">1</span>]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//初始化</span><br>p1进程:<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">flag</span>[<span class="hljs-number">0</span>]);<span class="hljs-comment">//先判断对方有没有意愿进入临界区 若有则本进程等待</span><br><span class="hljs-built_in">flag</span>[<span class="hljs-number">1</span>]=ture;<span class="hljs-comment">//通过上面循环则表示对方不想进入 所以即可把自己的设为ture 上锁</span><br>critical section;<span class="hljs-comment">//访问临界资源</span><br><span class="hljs-built_in">flag</span>[<span class="hljs-number">1</span>]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//访问完毕表示不想在访问 解锁</span><br>remainder section:<span class="hljs-comment">//剩余其他操作</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">        双标志检查法主要是违反慢则等待原则(如果两个进程并发执行则可能会同时进入访问临界区 按照152637顺序会违反)        原因在于,进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后,“上锁”前可能发生进程切换</code></pre><p><img src="/os/%E5%8F%8C%E6%A0%87%E5%89%8D%E6%A3%80%E6%9F%A5%E6%B3%95.png" alt="图示"></p><pre><code class="hljs">    双标志后检查法:            </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>四大件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2025/01/25/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2025/01/25/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>八大排序总结,方便以后回来时不时回来看看复习</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//算法优化,如果剩下的数已经有序了就不用在遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>&amp;&amp;flag==<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//外层循环遍历每一个数 内层循环选出每轮最小/大的数 </span><br>&#123;<br>flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len<span class="hljs-number">-1</span>-i;j++)<span class="hljs-comment">//排除最后已经排好的数字 </span><br>&#123;<br><span class="hljs-keyword">if</span>(arr[j]&gt;arr[j<span class="hljs-number">+1</span>])<br>&#123;<br>flag=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> temp=arr[j];<br>arr[j]=arr[j<span class="hljs-number">+1</span>];<br>arr[j<span class="hljs-number">+1</span>]=temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//flag的意义是设定一个检查看是否剩下未排序的数已经有序,如果已经有</span><br><span class="hljs-comment">//序就不用在进行后续遍历了,是算法优化. </span><br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>健身随谈(持续更新)</title>
    <link href="/2024/12/11/%E5%81%A5%E8%BA%AB%E9%9A%8F%E8%B0%88/"/>
    <url>/2024/12/11/%E5%81%A5%E8%BA%AB%E9%9A%8F%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>我是从2024年3月3日开始健身的,写这个文章的目的是把自己从健身到现在走过坑和所有的健身计划和个人感受分享给大家,以及随着我的年限增加我也会及时修改我这个文章里不太正确的观点,我会随着我所学习到的东西及时更新和修改文章.</p><p>截至2024年11月,健身第8个月,一直保持自重65kg,目前杠铃卧推85kg可以做5×5,深蹲100kg可以做5×5,引体向上可以负重10kg做10×10,自重大概可以极限做30个不到,硬拉只能拉100极限(因为我硬拉目前为止才练3个月再加上一直不敢上重量怕受伤和动作不规范就导致硬拉很菜),实力推是45kg做5×5.说这些是因为我认为我个人进步很快计划很合适所以打算总结出来写一篇文章分享给大家(当然我有一定的运动基础,之前喜欢打篮球,但是也只是爱好者没有多厉害),我只会分享我觉得我练的可以动作或者了解的东西,如果有我不了解或者不太了解的东西我也不会分享以免误导大家.</p><p>关于我个人的详细训练计划和动作我会放在第五章去分享</p><p>此文章仅是分享,不是指导和建议,根据自身仅供参考(也是我的一个复盘和记录),整篇文章如果提到任何产品或商品或博主无广,只是个人觉得好做推荐.</p><h1 id="第一部分训练思路"><a href="#第一部分训练思路" class="headerlink" title="第一部分训练思路:"></a>第一部分训练思路:</h1><h5 id="这一部分的内容我认为是最重要的东西-俗话说的好-健身先健脑-想要有一个好的健身反馈就要有一个好的-适合自己的训练思路"><a href="#这一部分的内容我认为是最重要的东西-俗话说的好-健身先健脑-想要有一个好的健身反馈就要有一个好的-适合自己的训练思路" class="headerlink" title="这一部分的内容我认为是最重要的东西,俗话说的好,健身先健脑,想要有一个好的健身反馈就要有一个好的,适合自己的训练思路"></a>这一部分的内容我认为是最重要的东西,俗话说的好,健身先健脑,想要有一个好的健身反馈就要有一个好的,适合自己的训练思路</h5><p>首先我先说的是也是最重要的就是我的训练思路,我认为健身是服务于生活的,所以生活是最主要的健身是次要的,所以我不会急于求成再加上我认为健身最好的天赋不是肌肉和力量增长的有多么快而是可以一直保持不受伤稳定的进步和不影响生活,所以在这里想要告诉大家的是不要急于求成,越着急越容易受伤越没有想要的回报.</p><p>再者,健身既然是服务于生活的,两者的主次不能颠倒,生活和身体健康是第一位.尽管有很多人想练出很大的肌肉但是真的健康吗</p><p>我的训练方式会尽可能的选择复合式动作(如果你是0基础健身小白(我指的是完完全全没有运动习惯的人群,哪怕你有一点的运动习惯都可以直接开始作复合动作)先不用遵循这个原则先去看第二部分),第一点复合动作它可以调集全身大部分肌肉共同发力和孤立训练往往相反,会有很多的溢出效应比如说三大项(杠铃深蹲,杠铃卧推,杠铃硬拉).第二点复合运动也代表着高风险高收益,这一点就表明我们不能盲目上重量和冲重量一定要在安全和自己能够承受的范围内去练复合动作,不要被身边的训练小伙伴’蛊惑’冲重量,无论什么训练计划和思路安全永远是第一位而且复合动作受的伤往往都是很严重,不可逆,伴随一生的,所以一定要很慎重.</p><h1 id="第二部分关于开始健身"><a href="#第二部分关于开始健身" class="headerlink" title="第二部分关于开始健身:"></a>第二部分关于开始健身:</h1><p>首先我是不推荐小白(无运动习惯)直接去健身房的,刚刚开始在家做做俯卧撑和卷腹(类似这种的变式也可以)即可,先积累一点力量和肌肉还有关节强度再去健身房健身,要不然刚刚开始没有运动基础很容易受伤,在家运动大概一个月左右的时间就可以去健身房了.步入健身房之后就像我第一部分所说的那样不要一开始就练太难的复合型动作(比如说:实力推,硬拉,杠铃划船)因为很容易受伤的,杠铃卧推和杠铃深蹲这类黄金动作还是可以慢慢练的,但是刚刚开始我推荐先做孤立器械先练上一阵子比如说1个月左右时间然后再把重心调整到三大项或者复合型动作,即把中心放在孤立器械上把孤立器械的相关训练当作主项,而复合动作在这一阶段去放到次要,在这一阶段重在打好良好的动作习惯和正确发力习惯之后在上重量,如果一开始就没有好的习惯和动作后面上了重量很容易会受伤而且到那时候想改也相对不容易了.</p><p>大家应该都听说过新手福利期,每个人的长短都不同,我的新手福利期大概有6个月左右.之所以提这个的原因是大家千万不能有一种心里’趁着新手福利期多练练累一点也无所谓或者盲目冲重量’,这个念头显然是错误的,只要你新手福利期保持不受伤你就可以进步飞快,因为我在福利期手腕受过两次小伤影响了有一段时间的训练但是好在伤病不严重很快的恢复过来了然后想明白了这个道理只后就会很小心的慢慢增加重量,之后再也没受过伤.所以大家如果可以不受伤肯定进步要比我快很多不用纠结于新手福利期是否要把自己逼那么累.心急吃不了热豆腐.</p><h1 id="第三部分关于补给"><a href="#第三部分关于补给" class="headerlink" title="第三部分关于补给:"></a>第三部分关于补给:</h1><h1 id="第四部分关于训练分化"><a href="#第四部分关于训练分化" class="headerlink" title="第四部分关于训练分化:"></a>第四部分关于训练分化:</h1><h1 id="第五部分关于训练伤病"><a href="#第五部分关于训练伤病" class="headerlink" title="第五部分关于训练伤病:"></a>第五部分关于训练伤病:</h1><h1 id="第六部分三大项"><a href="#第六部分三大项" class="headerlink" title="第六部分三大项:"></a>第六部分三大项:</h1><p>之所以把三大项单独拿出来说是因为它真的太太太重要了,三大项练的好的人其他项目绝对不烂但是反之就不一定了,而且三大项的溢出效应也是很高的,但是相对其他动作来说会稍微危险一点,但是永远都是高风险高收益如果你有需求或者希望进步快可以试着在训练里加入三大项(以安全为第一的前提下,动作一定要规范)</p><p>三大项刚刚开始训练的时候不要着急加重 一开始先把动作基础打好 三大项的动作永远都不会标准的需要随时改正和自己打磨 我的动作也不标准</p><h3 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲:"></a>深蹲:</h3><p>注意事项(这些要点都是我训练时犯过的错):<br>1.一定要全程注意力集中不要思想抛锚,脑子里时时刻刻注意要点(很多受伤都是因为注意力没有集中导致的目标集群松懈然后受伤)</p><p>2.大腿全程保持张力,下降到底端的时候大腿不要松懈,蹲到幅度后不要停顿(如果你想提高深蹲成绩可以训练底端暂停深蹲)顺势起来(做连贯)(我经常下降起来的时候做不连贯底部都要微微停顿一下,也就是力的传导不连贯 断层了,我最近才纠正过来(2025.2.23)因为我发现我在底端大腿会松懈一下然后才发力)</p><p>3.蹲到底端起来的时候不仅要做到第二条的连贯顺势,还要一点要注意在底端起来的时候不要先抬臀(伤腰),可以臀发力但是主要还是以腿发力为主一定要注意力集中让腿部集中发力(我很长一段时间一上大重量就尾巴骨那部分疼不知道原因,但是当我意识到我在底端没有以腿发力为主导再加上注意力没有放在腿上和先抬臀导致剪切力很大(主要还是注意力没有放在腿上思想抛锚了,所以说注意力集中真的很重要)导致腰和尾巴骨那部分疼,我改掉这个问题之后就好了很多)</p><h3 id="卧推"><a href="#卧推" class="headerlink" title="卧推:"></a>卧推:</h3><h3 id="硬拉"><a href="#硬拉" class="headerlink" title="硬拉:"></a>硬拉:</h3><h1 id="第七部分关于训练计划和训练动作详细思路分享"><a href="#第七部分关于训练计划和训练动作详细思路分享" class="headerlink" title="第七部分关于训练计划和训练动作详细思路分享:"></a>第七部分关于训练计划和训练动作详细思路分享:</h1><h3 id="胸部训练"><a href="#胸部训练" class="headerlink" title="胸部训练:"></a>胸部训练:</h3><h3 id="肩部训练"><a href="#肩部训练" class="headerlink" title="肩部训练:"></a>肩部训练:</h3><h3 id="腿部训练"><a href="#腿部训练" class="headerlink" title="腿部训练:"></a>腿部训练:</h3><h3 id="背部训练"><a href="#背部训练" class="headerlink" title="背部训练:"></a>背部训练:</h3><h3 id="腹部and核心训练"><a href="#腹部and核心训练" class="headerlink" title="腹部and核心训练:"></a>腹部and核心训练:</h3><h3 id="手臂训练"><a href="#手臂训练" class="headerlink" title="手臂训练:"></a>手臂训练:</h3><h3 id="有氧"><a href="#有氧" class="headerlink" title="有氧:"></a>有氧:</h3><h3 id="关于拉伸和关节灵活性"><a href="#关于拉伸和关节灵活性" class="headerlink" title="关于拉伸和关节灵活性:"></a>关于拉伸和关节灵活性:</h3><h1 id="第八部分关于饮食"><a href="#第八部分关于饮食" class="headerlink" title="第八部分关于饮食:"></a>第八部分关于饮食:</h1><h1 id="第九部分关于休息and轻训周"><a href="#第九部分关于休息and轻训周" class="headerlink" title="第九部分关于休息and轻训周:"></a>第九部分关于休息and轻训周:</h1><h1 id="第十部分关于瓶颈期"><a href="#第十部分关于瓶颈期" class="headerlink" title="第十部分关于瓶颈期:"></a>第十部分关于瓶颈期:</h1><h1 id="第十一部分其他"><a href="#第十一部分其他" class="headerlink" title="第十一部分其他:"></a>第十一部分其他:</h1><p>这一部分不太好分类所以我就打算把能想到的都在这里写到(当然会在这里分类的)</p><h3 id="推荐的博主"><a href="#推荐的博主" class="headerlink" title="推荐的博主:"></a>推荐的博主:</h3><p>这一部分给大家分享一下我比较喜欢的博主,现在互联网时代我认为完全没有必要请私教,可以从网络上学到很多东西,这些博主我认为教的东西都很干,排名不分先后.</p><h5 id="凯圣王"><a href="#凯圣王" class="headerlink" title="凯圣王:"></a>凯圣王:</h5><p>不必多说,新手健身路上的必备老师,教的东西和每期视频都很干货,无论是理论知识还是实际都很干,涉及各个方面:训练,拉伸,热身,饮食…..他还出过三分化跟练视频,真的就是手把手健身了.</p><h5 id="自强不息归来"><a href="#自强不息归来" class="headerlink" title="自强不息归来:"></a>自强不息归来:</h5><p>这个博主也是健身多年的大佬,他视频讲的东西更贴近生活和普通人,饮食和训练方法也更大众化一些,包括他介绍的补给视频也很通俗易懂,他的视频风格我也很喜欢,教学视频也很长.</p><h5 id="大海运动表现"><a href="#大海运动表现" class="headerlink" title="大海运动表现"></a>大海运动表现</h5><h5 id="叶先生爱健身"><a href="#叶先生爱健身" class="headerlink" title="叶先生爱健身"></a>叶先生爱健身</h5><h5 id="力训闫宁"><a href="#力训闫宁" class="headerlink" title="力训闫宁"></a>力训闫宁</h5><h5 id="怪兽拖鞋战神"><a href="#怪兽拖鞋战神" class="headerlink" title="怪兽拖鞋战神"></a>怪兽拖鞋战神</h5><h5 id="力量矩阵"><a href="#力量矩阵" class="headerlink" title="力量矩阵"></a>力量矩阵</h5>]]></content>
    
    
    
    <tags>
      
      <tag>健身</tag>
      
      <tag>分享</tag>
      
      <tag>杂谈</tag>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql server笔记 自用(已完结)</title>
    <link href="/2024/12/06/sql-server-note/"/>
    <url>/2024/12/06/sql-server-note/</url>
    
    <content type="html"><![CDATA[<h1 id="通过此视频学习"><a href="#通过此视频学习" class="headerlink" title="通过此视频学习"></a>通过此<a href="https://www.bilibili.com/video/BV1XV411C7TP/?p=20&share_source=copy_web&vd_source=ac0a2bcc69a50ded81b076abe6ec8d55">视频</a>学习</h1><h5 id="细节注意点-在sql-server中注释是使用-–-–-两个-字符串是使用-‘’-单引号-注意与其他语言的注释和字符串语法不一样"><a href="#细节注意点-在sql-server中注释是使用-–-–-两个-字符串是使用-‘’-单引号-注意与其他语言的注释和字符串语法不一样" class="headerlink" title="细节注意点:在sql server中注释是使用 –  –(两个-) ,字符串是使用 ‘’ (单引号),注意与其他语言的注释和字符串语法不一样"></a>细节注意点:在sql server中注释是使用 –  –(两个-) ,字符串是使用 ‘’ (单引号),注意与其他语言的注释和字符串语法不一样</h5><h2 id="第一部分-数据库的创建"><a href="#第一部分-数据库的创建" class="headerlink" title="第一部分:数据库的创建"></a>第一部分:数据库的创建</h2><p>语法: create database 库名<br>在创建数据库的时候可以选择建立日志文件和数据文件,紧跟着create table 库名 下面写<br>也可以快速创建数据库即只用写create table 库名,下面不用跟任何东西,数据文件和日志文件都是默认值<br>数据文件语法: on(name&#x3D;’逻辑名’,filename&#x3D;’物理路径以及名称’,size&#x3D;文件的初始大小,filegrowth&#x3D;)<br>日志文件语法: log on(name&#x3D;’逻辑名’,filename&#x3D;’物理路径以及名称’,size&#x3D;文件的初始大小,filegrowth&#x3D;)<br>&#x2F;&#x2F;括号里是文件需要的所含信息,文件增长方式可以是百分比也可以是具体大小,如果是百分比则后面不用加单位,如果是具体增长数值后面要加单位</p><h4 id="注意在写括号里的所含信息的时候每一项写完要加-‘-‘-最后一项不用加-‘-‘"><a href="#注意在写括号里的所含信息的时候每一项写完要加-‘-‘-最后一项不用加-‘-‘" class="headerlink" title="注意在写括号里的所含信息的时候每一项写完要加 ‘ , ‘   最后一项不用加 ‘ , ‘"></a>注意在写括号里的所含信息的时候每一项写完要加 ‘ , ‘   最后一项不用加 ‘ , ‘</h4><p><img src="/sql_sever_notepic/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA.png" alt="例子"></p><h2 id="第二部分-表的创建"><a href="#第二部分-表的创建" class="headerlink" title="第二部分:表的创建"></a>第二部分:表的创建</h2><p>语法: create table 表名{}           &#x2F;&#x2F;括号里是文件需要的所含信息<br>如果表名和保留字相同要将保留字用[]围起来,例如:[Rank]<br><img src="/sql_sever_notepic/%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA.png" alt="例子"><br>在表里写包含信息的时候先写名称再写类型然后再写其他信息<br>primary key是主键的意思    references是外键的意思   check是约束的意思<br>identy(a,b)&#x2F;&#x2F;此函数是自动增长的意思从a开始增长量为b</p><p>char,varchar,narvchar,text的区别:<br><img src="/sql_sever_notepic/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB.png" alt="例子"></p><p>删除表语法:drop table 表名</p><h2 id="第三部分-表的修改"><a href="#第三部分-表的修改" class="headerlink" title="第三部分:表的修改"></a>第三部分:表的修改</h2><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><p>语法:alter table 表名 add 列名 数据类型<br>eg:alter table people add peoplemail varchar(20)</p><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p>语法:alter table 表名 drop column 列名<br>eg:alter table people drop column peoplemail</p><h4 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h4><p>语法:alter table 表名 alter column 列名 数据类型<br>eg:alter table people alter column peopleaddress narchar(300)       &#x2F;&#x2F;修改varchar(200)为varchar(300)</p><h4 id="维护约束-删除-添加"><a href="#维护约束-删除-添加" class="headerlink" title="维护约束(删除,添加)"></a>维护约束(删除,添加)</h4><h6 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h6><p>语法:alter table 表名 drop constraint 约束名</p><h6 id="添加约束-check约束"><a href="#添加约束-check约束" class="headerlink" title="添加约束(check约束)"></a>添加约束(check约束)</h6><p>语法:alter table 表名 add constraint 约束名 check(表达式)<br><img src="/sql_sever_notepic/%E7%BA%A6%E6%9D%9F%E5%8F%98%E5%8C%96.png" alt="例子"></p><h6 id="添加约束-主键-唯一-默认值-外键约束"><a href="#添加约束-主键-唯一-默认值-外键约束" class="headerlink" title="添加约束(主键,唯一,默认值,外键约束)"></a>添加约束(主键,唯一,默认值,外键约束)</h6><p><img src="/sql_sever_notepic/%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F.png" alt="例子"></p><h2 id="第三部分-插入数据"><a href="#第三部分-插入数据" class="headerlink" title="第三部分:插入数据"></a>第三部分:插入数据</h2><p>语法:insert into 表名(列名,…,…)values(…,…,…)<br><img src="/sql_sever_notepic/%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.png" alt="例子"></p><p>一次性插入多行数据<br><img src="/sql_sever_notepic/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%8F%92%E5%85%A5%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE.png" alt="例子"></p><h2 id="第四部分-修改数据"><a href="#第四部分-修改数据" class="headerlink" title="第四部分:修改数据"></a>第四部分:修改数据</h2><h4 id="修改"><a href="#修改" class="headerlink" title="修改:"></a>修改:</h4><p>语法:update 表名 set 字段1&#x3D;值1,字段2&#x3D;值2 where 条件<br><img src="/sql_sever_notepic/%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE.png" alt="例子"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>语法:delete from 表名 where 条件<br><img src="/sql_sever_notepic/%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.png" alt="例子"><br>关于drop,truncate,delete的区别:<br>drop table &#x2F;&#x2F;删除表对象<br>truncate table &#x2F;&#x2F;删除数据(清空数据),表对象即结构依旧才存在<br>delete from 删除所有数据,表对象即结构依然存在<br><img src="/sql_sever_notepic/delete%E5%8C%BA%E5%88%AB.png" alt="其他区别"></p><h2 id="第五部分-查询"><a href="#第五部分-查询" class="headerlink" title="第五部分:查询"></a>第五部分:查询</h2><p>查询所有 语法:select*from 表名<br>查询其中的指定部分列 语法:select 指定列名 起的别名,指定列名,…. from 表名<br><img src="/sql_sever_notepic/%E6%9F%A5%E8%AF%A2.png" alt="例子"></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询:"></a>条件查询:</h4><p>关于between…and…,in(),升序,降序的用法<br><img src="/sql_sever_notepic/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2.png" alt="例子"></p><p>关于top,null查询用法<br><img src="/sql_sever_notepic/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A21.png" alt="例子"></p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询:"></a>模糊查询:</h4><p>%和_的区别:<br>%代表有0个或多个字符,_代表只有一个字符<br><img src="/sql_sever_notepic/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2.png" alt="例子"><br>eg:select * from people where peoplephone&#x3D;’137[7,8]%5’&#x2F;&#x2F;代表电话号码为127开头第四位好像是7或8最后一个号码是5            如果要表达不是7或8即[^7,8]  加上^符号</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询:"></a>分组查询:</h4><p>语法:group by ….<br><img src="/themes/fluid/source/sql_sever_notepic/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2.png" alt="例子"></p><h4 id="多表查询-笛卡尔乘积"><a href="#多表查询-笛卡尔乘积" class="headerlink" title="多表查询(笛卡尔乘积):"></a>多表查询(笛卡尔乘积):</h4><h6 id="方法一-where…-and…连接"><a href="#方法一-where…-and…连接" class="headerlink" title="方法一(where….and…连接):"></a>方法一(where….and…连接):</h6><p><img src="/sql_sever_notepic/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E4%B8%80.png" alt="例子"></p><h6 id="方法二-inner-join…on…连接-内连接方法"><a href="#方法二-inner-join…on…连接-内连接方法" class="headerlink" title="方法二(inner join…on…连接)内连接方法:"></a>方法二(inner join…on…连接)内连接方法:</h6><p><img src="/themes/fluid/source/sql_sever_notepic/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E4%BA%8C.png" alt="例子"></p><h6 id="方法三外连接-左外连-右外连-全外连"><a href="#方法三外连接-左外连-右外连-全外连" class="headerlink" title="方法三外连接(左外连,右外连,全外连):"></a>方法三外连接(左外连,右外连,全外连):</h6><p>左外连(letf join…on…)以左表为主进行数据显示,主外键关系找不到的数据null代替,即左表全都显示不管符不符合条件:<br><img src="/sql_sever_notepic/%E5%B7%A6%E5%A4%96%E8%81%94.png" alt="例子"><br>右外连(right join…on…)以右表为主进行数据显示,主外键关系找不到的数据null代替,即右表全都显示不管符不符合条件:<br>注意左连和右连的关系<br><img src="/sql_sever_notepic/%E5%8F%B3%E8%BF%9E%E6%8E%A5.png" alt="例子"><br>全外连(full join…on…)两张表的数据,无论是否符合关系,都要显示:<br><img src="/sql_sever_notepic/%E5%85%A8%E8%BF%9E%E6%8E%A5.png" alt="例子"></p><h2 id="第六部分-聚合函数"><a href="#第六部分-聚合函数" class="headerlink" title="第六部分:聚合函数"></a>第六部分:聚合函数</h2><p>如何求总人数,最大值,最小值,求和,求平均值<br><img src="/sql_sever_notepic/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0.png" alt="例子"></p><h2 id="第七部分-变量"><a href="#第七部分-变量" class="headerlink" title="第七部分:变量"></a>第七部分:变量</h2><h4 id="信息打印"><a href="#信息打印" class="headerlink" title="信息打印:"></a>信息打印:</h4><p>print ‘hello’ 或者 select ‘hello’</p><h4 id="变量-全局变量和局部变量"><a href="#变量-全局变量和局部变量" class="headerlink" title="变量(全局变量和局部变量)"></a>变量(全局变量和局部变量)</h4><p>注意定义的时候和别的语言不同,数据类型是写在后面.</p><p>赋值set 和 select都可以,两者的区别:<br><img src="/sql_sever_notepic/select%E5%92%8Cset%E5%8C%BA%E5%88%AB.png" alt="例子"></p><p>全局变量(以@@开头,先声明在赋值):<br><img src="/sql_sever_notepic/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.png" alt="例子"></p><p>局部变量(以@开头,先声明在赋值):<br><img src="/sql_sever_notepic/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.png" alt="例子"></p><h4 id="go语句"><a href="#go语句" class="headerlink" title="go语句:"></a>go语句:</h4><p><img src="/sql_sever_notepic/go%E8%AF%AD%E5%8F%A5.png" alt="例子"></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符:"></a>运算符:</h4><p>运算符和其他语言几乎一样除了!&#x3D;在sql server里是&lt;&gt;</p><h2 id="第八部分-流程控制"><a href="#第八部分-流程控制" class="headerlink" title="第八部分:流程控制"></a>第八部分:流程控制</h2><h4 id="if"><a href="#if" class="headerlink" title="if:"></a>if:</h4><p><img src="/sql_sever_notepic/if.png" alt="例子"></p><h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case:"></a>switch-case:</h4><p><img src="/sql_sever_notepic/switch.png" alt="例子"></p><h4 id="while"><a href="#while" class="headerlink" title="while:"></a>while:</h4><p><img src="/sql_sever_notepic/while.png" alt="例子"></p><h2 id="第九部分-分页"><a href="#第九部分-分页" class="headerlink" title="第九部分:分页"></a>第九部分:分页</h2><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h4><p><img src="/sql_sever_notepic/%E5%88%86%E9%A1%B5%E6%96%B9%E6%B3%95%E4%B8%80.png" alt="例子"></p><h4 id="方法二-row-number"><a href="#方法二-row-number" class="headerlink" title="方法二(row_number):"></a>方法二(row_number):</h4><p><img src="/sql_sever_notepic/%E5%88%86%E9%A1%B5%E6%96%B9%E6%B3%95%E4%BA%8C.png" alt="例子"></p><h2 id="第十部分-事务-绑定在一起"><a href="#第十部分-事务-绑定在一起" class="headerlink" title="第十部分:事务(绑定在一起)"></a>第十部分:事务(绑定在一起)</h2><p>要么同时成功,要么就失败然后回滚<br><img src="/sql_sever_notepic/%E4%BA%8B%E5%8A%A11.png" alt="例子"><br><img src="/sql_sever_notepic/%E4%BA%8B%E5%8A%A12.png" alt="例子"></p><h2 id="第十一部分-索引-提高查询效率"><a href="#第十一部分-索引-提高查询效率" class="headerlink" title="第十一部分:索引(提高查询效率)"></a>第十一部分:索引(提高查询效率)</h2><p>分为聚集索引和非聚集索引:<br><img src="/sql_sever_notepic/%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB.png" alt="例子"></p><p>非聚集索引的相关操作:<br><img src="/sql_sever_notepic/%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C.png" alt="例子"></p><h2 id="第十二部分-视图"><a href="#第十二部分-视图" class="headerlink" title="第十二部分:视图"></a>第十二部分:视图</h2><p>可以理解为一个虚拟表,而且可以对视图进行操作但是不建议,不会改变原表,如果要修改还是对原表修改.<br>语法:<br><img src="/sql_sever_notepic/%E8%A7%86%E5%9B%BE%E8%AF%AD%E6%B3%95.png" alt="例子"><br>相关操作:<br><img src="/sql_sever_notepic/%E8%A7%86%E5%9B%BE%E6%93%8D%E4%BD%9C.png" alt="例子"></p><h2 id="第十三部分-游标"><a href="#第十三部分-游标" class="headerlink" title="第十三部分:游标"></a>第十三部分:游标</h2><p>定位到结果集中的某一行<br>游标分类:<br><img src="/sql_sever_notepic/%E6%B8%B8%E6%A0%87%E5%88%86%E7%B1%BB.png" alt="例子"></p><p>游标操作:<br><img src="/sql_sever_notepic/%E6%B8%B8%E6%A0%87%E6%93%8D%E4%BD%9C.png" alt="例子"></p><p>游标遍历:<br><img src="/sql_sever_notepic/%E6%B8%B8%E6%A0%87%E9%81%8D%E5%8E%86.png" alt="例子"></p><h2 id="第十四部分-函数"><a href="#第十四部分-函数" class="headerlink" title="第十四部分:函数"></a>第十四部分:函数</h2><p><img src="/sql_sever_notepic/%E5%87%BD%E6%95%B01.png" alt="例子"></p><p>函数操作语法(删除 建立 调用(调用使用select)):</p><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数:"></a>无参数:</h4><p><img src="/sql_sever_notepic/%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C.png" alt="例子"></p><h4 id="有参数"><a href="#有参数" class="headerlink" title="有参数:"></a>有参数:</h4><p><img src="/sql_sever_notepic/%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C2.png" alt="例子"></p><h2 id="第十五部分-触发器"><a href="#第十五部分-触发器" class="headerlink" title="第十五部分:触发器"></a>第十五部分:触发器</h2><p>触发器:类似于捆绑在一起发生和操作<br>类别:<br><img src="/sql_sever_notepic/%E8%A7%A6%E5%8F%91%E5%99%A8%601.png" alt="例子"></p><p>例子:在插入后触发(注意写as和go):<br><img src="/sql_sever_notepic/insert%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="例子"></p><p>不仅可以是insert,还可以是delete,update……</p><h2 id="第十六部分-存储过程"><a href="#第十六部分-存储过程" class="headerlink" title="第十六部分:存储过程"></a>第十六部分:存储过程</h2><p>存储过程和函数的区别:函数只能被sql server调用而存储过程可以呗外部调用<br>语法(删除 定义 调用):<br>无参数:<br><img src="/sql_sever_notepic/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B1.png" alt="例子"></p><p>有参数:<br><img src="/sql_sever_notepic/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B2.png" alt="例子"></p><h2 id="完结-此文章仅自用为了应付期末考试复习-记的比较潦草"><a href="#完结-此文章仅自用为了应付期末考试复习-记的比较潦草" class="headerlink" title="完结 此文章仅自用为了应付期末考试复习,记的比较潦草"></a>完结 此文章仅自用为了应付期末考试复习,记的比较潦草</h2>]]></content>
    
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>语言</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>First blog,Hello!</title>
    <link href="/2024/12/01/hello-world/"/>
    <url>/2024/12/01/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="大家好-第一次开始写博客来记录-决定记录一下自己的学习历程以及经验分享还有健身计划和经验分享-希望可以帮助大家-欢迎大家和我来一起讨论"><a href="#大家好-第一次开始写博客来记录-决定记录一下自己的学习历程以及经验分享还有健身计划和经验分享-希望可以帮助大家-欢迎大家和我来一起讨论" class="headerlink" title="大家好,第一次开始写博客来记录,决定记录一下自己的学习历程以及经验分享还有健身计划和经验分享,希望可以帮助大家,欢迎大家和我来一起讨论."></a>大家好,第一次开始写博客来记录,决定记录一下自己的学习历程以及经验分享还有健身计划和经验分享,希望可以帮助大家,欢迎大家和我来一起讨论.</h3><h1 id="———健身记录"><a href="#———健身记录" class="headerlink" title="———健身记录:"></a>———健身记录:</h1><p>欢迎大家随时来看我的<a href="https://v.douyin.com/iDQAgR6n/">抖音</a>和我一起讨论健身内容,有需要或者想问我的训练计划和思路方法的可以随时私信我,希望可以帮助到大家,免费,共勉!</p><h1 id="———学习记录"><a href="#———学习记录" class="headerlink" title="———学习记录:"></a>———学习记录:</h1><p>目前大二在校,会慢慢写博客来记录自己的学习路程以及当作笔记来回归,如果发现笔记中有<br>错误的小伙伴欢迎来找我指出<a href="https://github.com/kunkun0103">GIthub</a>,感谢大家.</p><h2 id="———初次见面到这里就结束了-希望可以在学习这条路上越走越远-同时希望帮助到更多人-共勉"><a href="#———初次见面到这里就结束了-希望可以在学习这条路上越走越远-同时希望帮助到更多人-共勉" class="headerlink" title="———初次见面到这里就结束了,希望可以在学习这条路上越走越远,同时希望帮助到更多人,共勉!"></a>———初次见面到这里就结束了,希望可以在学习这条路上越走越远,同时希望帮助到更多人,共勉!</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
